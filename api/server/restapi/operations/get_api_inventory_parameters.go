// Code generated by go-swagger; DO NOT EDIT.

package operations

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"net/http"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/runtime"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// NewGetAPIInventoryParams creates a new GetAPIInventoryParams object
// with the default values initialized.
func NewGetAPIInventoryParams() GetAPIInventoryParams {

	var (
		// initialize parameters with default values

		sortDirDefault = string("ASC")
	)

	return GetAPIInventoryParams{
		SortDir: &sortDirDefault,
	}
}

// GetAPIInventoryParams contains all the bound params for the get API inventory operation
// typically these are obtained from a http.Request
//
// swagger:parameters GetAPIInventory
type GetAPIInventoryParams struct {

	// HTTP Request Object
	HTTPRequest *http.Request `json:"-"`

	/*api id to return
	  In: query
	*/
	APIID *string
	/*
	  In: query
	*/
	HasProvidedSpecIs *bool
	/*
	  In: query
	*/
	HasReconstructedSpecIs *bool
	/*
	  In: query
	*/
	NameContains []string
	/*
	  In: query
	*/
	NameEnd *string
	/*
	  In: query
	*/
	NameIsNot []string
	/*
	  In: query
	*/
	NameIs []string
	/*
	  In: query
	*/
	NameStart *string
	/*Page number of the query
	  Required: true
	  In: query
	*/
	Page int64
	/*Maximum items to return
	  Required: true
	  Maximum: 50
	  Minimum: 1
	  In: query
	*/
	PageSize int64
	/*
	  In: query
	*/
	PortIsNot []string
	/*
	  In: query
	*/
	PortIs []string
	/*Sorting direction
	  In: query
	  Default: "ASC"
	*/
	SortDir *string
	/*Sort key
	  Required: true
	  In: query
	*/
	SortKey string
	/*API type [INTERNAL or EXTERNAL]
	  Required: true
	  In: query
	*/
	Type string
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
// for simple values it will use straight method calls.
//
// To ensure default values, the struct must have been initialized with NewGetAPIInventoryParams() beforehand.
func (o *GetAPIInventoryParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
	var res []error

	o.HTTPRequest = r

	qs := runtime.Values(r.URL.Query())

	qAPIID, qhkAPIID, _ := qs.GetOK("apiId")
	if err := o.bindAPIID(qAPIID, qhkAPIID, route.Formats); err != nil {
		res = append(res, err)
	}

	qHasProvidedSpecIs, qhkHasProvidedSpecIs, _ := qs.GetOK("hasProvidedSpec[is]")
	if err := o.bindHasProvidedSpecIs(qHasProvidedSpecIs, qhkHasProvidedSpecIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qHasReconstructedSpecIs, qhkHasReconstructedSpecIs, _ := qs.GetOK("hasReconstructedSpec[is]")
	if err := o.bindHasReconstructedSpecIs(qHasReconstructedSpecIs, qhkHasReconstructedSpecIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qNameContains, qhkNameContains, _ := qs.GetOK("name[contains]")
	if err := o.bindNameContains(qNameContains, qhkNameContains, route.Formats); err != nil {
		res = append(res, err)
	}

	qNameEnd, qhkNameEnd, _ := qs.GetOK("name[end]")
	if err := o.bindNameEnd(qNameEnd, qhkNameEnd, route.Formats); err != nil {
		res = append(res, err)
	}

	qNameIsNot, qhkNameIsNot, _ := qs.GetOK("name[isNot]")
	if err := o.bindNameIsNot(qNameIsNot, qhkNameIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qNameIs, qhkNameIs, _ := qs.GetOK("name[is]")
	if err := o.bindNameIs(qNameIs, qhkNameIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qNameStart, qhkNameStart, _ := qs.GetOK("name[start]")
	if err := o.bindNameStart(qNameStart, qhkNameStart, route.Formats); err != nil {
		res = append(res, err)
	}

	qPage, qhkPage, _ := qs.GetOK("page")
	if err := o.bindPage(qPage, qhkPage, route.Formats); err != nil {
		res = append(res, err)
	}

	qPageSize, qhkPageSize, _ := qs.GetOK("pageSize")
	if err := o.bindPageSize(qPageSize, qhkPageSize, route.Formats); err != nil {
		res = append(res, err)
	}

	qPortIsNot, qhkPortIsNot, _ := qs.GetOK("port[isNot]")
	if err := o.bindPortIsNot(qPortIsNot, qhkPortIsNot, route.Formats); err != nil {
		res = append(res, err)
	}

	qPortIs, qhkPortIs, _ := qs.GetOK("port[is]")
	if err := o.bindPortIs(qPortIs, qhkPortIs, route.Formats); err != nil {
		res = append(res, err)
	}

	qSortDir, qhkSortDir, _ := qs.GetOK("sortDir")
	if err := o.bindSortDir(qSortDir, qhkSortDir, route.Formats); err != nil {
		res = append(res, err)
	}

	qSortKey, qhkSortKey, _ := qs.GetOK("sortKey")
	if err := o.bindSortKey(qSortKey, qhkSortKey, route.Formats); err != nil {
		res = append(res, err)
	}

	qType, qhkType, _ := qs.GetOK("type")
	if err := o.bindType(qType, qhkType, route.Formats); err != nil {
		res = append(res, err)
	}
	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

// bindAPIID binds and validates parameter APIID from query.
func (o *GetAPIInventoryParams) bindAPIID(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.APIID = &raw

	return nil
}

// bindHasProvidedSpecIs binds and validates parameter HasProvidedSpecIs from query.
func (o *GetAPIInventoryParams) bindHasProvidedSpecIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("hasProvidedSpec[is]", "query", "bool", raw)
	}
	o.HasProvidedSpecIs = &value

	return nil
}

// bindHasReconstructedSpecIs binds and validates parameter HasReconstructedSpecIs from query.
func (o *GetAPIInventoryParams) bindHasReconstructedSpecIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}

	value, err := swag.ConvertBool(raw)
	if err != nil {
		return errors.InvalidType("hasReconstructedSpec[is]", "query", "bool", raw)
	}
	o.HasReconstructedSpecIs = &value

	return nil
}

// bindNameContains binds and validates array parameter NameContains from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIInventoryParams) bindNameContains(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvNameContains string
	if len(rawData) > 0 {
		qvNameContains = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	nameContainsIC := swag.SplitByFormat(qvNameContains, "")
	if len(nameContainsIC) == 0 {
		return nil
	}

	var nameContainsIR []string
	for _, nameContainsIV := range nameContainsIC {
		nameContainsI := nameContainsIV

		nameContainsIR = append(nameContainsIR, nameContainsI)
	}

	o.NameContains = nameContainsIR

	return nil
}

// bindNameEnd binds and validates parameter NameEnd from query.
func (o *GetAPIInventoryParams) bindNameEnd(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.NameEnd = &raw

	return nil
}

// bindNameIsNot binds and validates array parameter NameIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIInventoryParams) bindNameIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvNameIsNot string
	if len(rawData) > 0 {
		qvNameIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	nameIsNotIC := swag.SplitByFormat(qvNameIsNot, "")
	if len(nameIsNotIC) == 0 {
		return nil
	}

	var nameIsNotIR []string
	for _, nameIsNotIV := range nameIsNotIC {
		nameIsNotI := nameIsNotIV

		nameIsNotIR = append(nameIsNotIR, nameIsNotI)
	}

	o.NameIsNot = nameIsNotIR

	return nil
}

// bindNameIs binds and validates array parameter NameIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIInventoryParams) bindNameIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvNameIs string
	if len(rawData) > 0 {
		qvNameIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	nameIsIC := swag.SplitByFormat(qvNameIs, "")
	if len(nameIsIC) == 0 {
		return nil
	}

	var nameIsIR []string
	for _, nameIsIV := range nameIsIC {
		nameIsI := nameIsIV

		nameIsIR = append(nameIsIR, nameIsI)
	}

	o.NameIs = nameIsIR

	return nil
}

// bindNameStart binds and validates parameter NameStart from query.
func (o *GetAPIInventoryParams) bindNameStart(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		return nil
	}
	o.NameStart = &raw

	return nil
}

// bindPage binds and validates parameter Page from query.
func (o *GetAPIInventoryParams) bindPage(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("page", "query", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// AllowEmptyValue: false

	if err := validate.RequiredString("page", "query", raw); err != nil {
		return err
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("page", "query", "int64", raw)
	}
	o.Page = value

	return nil
}

// bindPageSize binds and validates parameter PageSize from query.
func (o *GetAPIInventoryParams) bindPageSize(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("pageSize", "query", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// AllowEmptyValue: false

	if err := validate.RequiredString("pageSize", "query", raw); err != nil {
		return err
	}

	value, err := swag.ConvertInt64(raw)
	if err != nil {
		return errors.InvalidType("pageSize", "query", "int64", raw)
	}
	o.PageSize = value

	if err := o.validatePageSize(formats); err != nil {
		return err
	}

	return nil
}

// validatePageSize carries on validations for parameter PageSize
func (o *GetAPIInventoryParams) validatePageSize(formats strfmt.Registry) error {

	if err := validate.MinimumInt("pageSize", "query", o.PageSize, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("pageSize", "query", o.PageSize, 50, false); err != nil {
		return err
	}

	return nil
}

// bindPortIsNot binds and validates array parameter PortIsNot from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIInventoryParams) bindPortIsNot(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvPortIsNot string
	if len(rawData) > 0 {
		qvPortIsNot = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	portIsNotIC := swag.SplitByFormat(qvPortIsNot, "")
	if len(portIsNotIC) == 0 {
		return nil
	}

	var portIsNotIR []string
	for _, portIsNotIV := range portIsNotIC {
		portIsNotI := portIsNotIV

		portIsNotIR = append(portIsNotIR, portIsNotI)
	}

	o.PortIsNot = portIsNotIR

	return nil
}

// bindPortIs binds and validates array parameter PortIs from query.
//
// Arrays are parsed according to CollectionFormat: "" (defaults to "csv" when empty).
func (o *GetAPIInventoryParams) bindPortIs(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var qvPortIs string
	if len(rawData) > 0 {
		qvPortIs = rawData[len(rawData)-1]
	}

	// CollectionFormat:
	portIsIC := swag.SplitByFormat(qvPortIs, "")
	if len(portIsIC) == 0 {
		return nil
	}

	var portIsIR []string
	for _, portIsIV := range portIsIC {
		portIsI := portIsIV

		portIsIR = append(portIsIR, portIsI)
	}

	o.PortIs = portIsIR

	return nil
}

// bindSortDir binds and validates parameter SortDir from query.
func (o *GetAPIInventoryParams) bindSortDir(rawData []string, hasKey bool, formats strfmt.Registry) error {
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: false
	// AllowEmptyValue: false

	if raw == "" { // empty values pass all other validations
		// Default values have been previously initialized by NewGetAPIInventoryParams()
		return nil
	}
	o.SortDir = &raw

	if err := o.validateSortDir(formats); err != nil {
		return err
	}

	return nil
}

// validateSortDir carries on validations for parameter SortDir
func (o *GetAPIInventoryParams) validateSortDir(formats strfmt.Registry) error {

	if err := validate.EnumCase("sortDir", "query", *o.SortDir, []interface{}{"ASC", "DESC"}, true); err != nil {
		return err
	}

	return nil
}

// bindSortKey binds and validates parameter SortKey from query.
func (o *GetAPIInventoryParams) bindSortKey(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("sortKey", "query", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// AllowEmptyValue: false

	if err := validate.RequiredString("sortKey", "query", raw); err != nil {
		return err
	}
	o.SortKey = raw

	if err := o.validateSortKey(formats); err != nil {
		return err
	}

	return nil
}

// validateSortKey carries on validations for parameter SortKey
func (o *GetAPIInventoryParams) validateSortKey(formats strfmt.Registry) error {

	if err := validate.EnumCase("sortKey", "query", o.SortKey, []interface{}{"name", "port", "hasReconstructedSpec", "hasProvidedSpec"}, true); err != nil {
		return err
	}

	return nil
}

// bindType binds and validates parameter Type from query.
func (o *GetAPIInventoryParams) bindType(rawData []string, hasKey bool, formats strfmt.Registry) error {
	if !hasKey {
		return errors.Required("type", "query", rawData)
	}
	var raw string
	if len(rawData) > 0 {
		raw = rawData[len(rawData)-1]
	}

	// Required: true
	// AllowEmptyValue: false

	if err := validate.RequiredString("type", "query", raw); err != nil {
		return err
	}
	o.Type = raw

	if err := o.validateType(formats); err != nil {
		return err
	}

	return nil
}

// validateType carries on validations for parameter Type
func (o *GetAPIInventoryParams) validateType(formats strfmt.Registry) error {

	if err := validate.EnumCase("type", "query", o.Type, []interface{}{"INTERNAL", "EXTERNAL"}, true); err != nil {
		return err
	}

	return nil
}
